# Copyright edalize contributors
# Licensed under the 2-Clause BSD License, see LICENSE for details.
# SPDX-License-Identifier: BSD-2-Clause

import os
import logging
import sys

from edalize.edatool import Edatool

logger = logging.getLogger(__name__)

MAKE_HEADER ="""#Generated by Edalize
ifeq (, $(shell which xmroot))
$(error "No Xcelium installation in $(PATH)")
endif

XCELIUM_HOME = $(shell xmroot)

RM ?= rm
INCS := -I$(XCELIUM_HOME)/tools/include

XRUN ?= $(XCELIUM_HOME)/tools/bin/xrun
XRUN_PREFIX  ?= {xrun_prefix}

TOPLEVEL      := {toplevel}
VPI_MODULES   := {modules}
PARAMETERS    ?= {parameters}
PLUSARGS      ?= {plusargs}
BUILD_OPTIONS ?= {elab_options}
XRUN_OPTIONS  ?= {run_options}


all: $(VPI_MODULES)

build:
	$(XRUN_PREFIX) xrun -elaborate  $(BUILD_OPTIONS) -top $(TOPLEVEL) -f edalize_main.f 
run_nc:
	$(XRUN_PREFIX) xrun -R -access rw $(XRUN_OPTIONS)

run: $(VPI_MODULES) build run_nc


run-gui: $(VPI_MODULES)
	$(XRUN_CALL) -gui -access rwc

clean: {clean_targets}
"""

VPI_MAKE_SECTION = """
{name}_OBJS := {objs}
{name}_LIBS := {libs}
{name}_INCS := $(INCS) {incs}

$({name}_OBJS): %.o : %.c
	$(CC) $(CFLAGS) $({name}_INCS) -o $@ $<

{name}: $({name}_OBJS)
	$(LD) $(LDFLAGS) -o $@ $? $({name}_LIBS)

clean_{name}:
	$(RM) $({name}_OBJS) {name}
"""

class Xcelium(Edatool):

    argtypes = ['plusarg', 'vlogdefine', 'vlogparam', 'generic']

    @classmethod
    def get_doc(cls, api_ver):
        if api_ver == 0:
            return {'description' : "Xcelium simulator from Cadence Design Systems",
                    'lists' : [
                        {'name' : 'elab_options',
                         'type' : 'String',
                         'desc' : 'Additional run options for xrun -elaboration'},
                        {'name' : 'xrun_prefix',
                         'type' : 'String',
                         'desc' : 'prefix for using submission servers like bjob or nc'},
                        {'name' : 'run_options',
                         'type' : 'String',
                         'desc' : 'Additional run options for xrun -R'},
                        ]}

    def _write_build_rtl_f_file(self, tcl_main):
        tcl_build_rtl  = open(os.path.join(self.work_root, "edalize_build_rtl.f"), 'w')
        tcl_build_c    = open(os.path.join(self.work_root, "edalize_build_c.f"), 'w')

        (src_files, incdirs) = self._get_fileset_files()
        vlog_include_dirs = ['+incdir+'+d.replace('\\','/') for d in incdirs]

        libs = []

        print("\n DEFINES::", file=sys.stderr)
        print(self.vlogdefine, file=sys.stderr)

        # add defines to file of files
        args = []
        for k, v in self.vlogdefine.items():
            args += ['+define+{}={}'.format(k,self._param_value_str(v))]

        # add inc dirs
        args += vlog_include_dirs
        line = "{}".format('\n'.join(args))
        tcl_build_rtl.write(line + '\n')

        # add rtl/c files
        for f in src_files:
            args = []
            if not f.logical_name:
                f.logical_name = 'worklib'
            if f.file_type.startswith("verilogSource") or \
               f.file_type.startswith("systemVerilogSource"):
                cmd = 'elab_opts'
                #place holder for any verilog specific per file option
            elif f.file_type.startswith("vhdlSource"):
                cmd = 'xmvhdl'
            elif f.file_type == 'cSource':
                cmd = None
                # C files get their own files of files
                #lets the user choose between build in or extern c compiler
                tcl_build_c.write("{}\n".format(f.name))
            elif f.file_type == 'tclSource':
                cmd = None
                tcl_main.write("-input {}\n".format(f.name))
            elif f.file_type == 'user':
                cmd = None
            else:
                _s = "{} has unknown file type '{}'"
                logger.warning(_s.format(f.name, f.file_type))
                cmd = None
            if cmd:
                args += [f.name.replace('\\','/')]
                line = "{}".format(' '.join(args))
                tcl_build_rtl.write(line + '\n')

    def _write_makefile(self):
        vpi_make = open(os.path.join(self.work_root, "Makefile"), 'w')
        _parameters = []
        for key, value in self.vlogparam.items():
            _parameters += ['{}={}'.format(key, self._param_value_str(value))]
        for key, value in self.generic.items():
            _parameters += ['{}={}'.format(key, self._param_value_str(value, bool_is_str=True))]
        _plusargs = []
        for key, value in self.plusarg.items():
            _plusargs += ['{}={}'.format(key, self._param_value_str(value))]

        _elab_options = self.tool_options.get('elab_options', [])
        _xrun_prefix  = self.tool_options.get('xrun_prefix', [])
        _xrun_options = self.tool_options.get('run_options', [])
        _modules = [m['name'] for m in self.vpi_modules]
        _clean_targets = ' '.join(["clean_"+m for m in _modules])
        _s = MAKE_HEADER.format(toplevel = self.toplevel,
                                parameters = ' '.join(_parameters),
                                plusargs = ' '.join(_plusargs),
                                elab_options = ' '.join(_elab_options),
                                run_options = ' '.join(_xrun_options),
                                xrun_prefix = ' '.join(_xrun_prefix),
                                modules = ' '.join(_modules),
                                clean_targets = _clean_targets)
        vpi_make.write(_s)

        for vpi_module in self.vpi_modules:
            _name = vpi_module['name']
            _objs = [os.path.splitext(s)[0]+'.o' for s in vpi_module['src_files']]
            _libs = ['-l'+l for l in vpi_module['libs']]
            _incs = ['-I'+d for d in vpi_module['include_dirs']]
            _s = VPI_MAKE_SECTION.format(name=_name,
                                         objs=' '.join(_objs),
                                         libs=' '.join(_libs),
                                         incs=' '.join(_incs))
            vpi_make.write(_s)

        vpi_make.close()

    def configure_main(self):
        tcl_main = open(os.path.join(self.work_root, "edalize_main.f"), 'w')
        tcl_main.write("-f edalize_build_c.f\n")
        tcl_main.write("-f edalize_build_rtl.f\n")

        self._write_build_rtl_f_file(tcl_main)
        self._write_makefile()
        tcl_main.close()

    def run_main(self):
        args = ['run']

        # Set plusargs
        if self.plusarg:
            plusargs = []
            for key, value in self.plusarg.items():
                plusargs += ['{}={}'.format(key, self._param_value_str(value))]
            args.append('PLUSARGS='+' '.join(plusargs))

        self._run_tool('make', args)
