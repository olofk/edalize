# Copyright edalize contributors
# Licensed under the 2-Clause BSD License, see LICENSE for details.
# SPDX-License-Identifier: BSD-2-Clause

import os
import logging

from edalize.edatool import Edatool

logger = logging.getLogger(__name__)

MAKE_HEADER = """#Generated by Edalize
ifeq (, $(shell which xmroot))
$(error "No Xcelium installation in $(PATH)")
endif

XCELIUM_HOME = $(shell xmroot)

CC = $(XCELIUM_HOME)/tools/cdsgcc/gcc/bin/gcc
CFLAGS := -c -std=c99 -fPIC -fno-stack-protector -g

CPP = $(XCELIUM_HOME)/tools/cdsgcc/gcc/bin/g++
CPPFLAGS := -std=c++11 -fPIC -g -shared -Bsymbolic

LD = $(XCELIUM_HOME)/tools/cdsgcc/gcc/bin/ld
LDCPPFLAGS := -fPIC -g -shared -Bsymbolic
LDFLAGS := -shared -E

#Only 32 bits is currently supported
# CFLAGS  += -m32
# LDFLAGS += -melf_i386

RM ?= rm
INCS := -I$(XCELIUM_HOME)/tools/include

XRUN ?= $(XCELIUM_HOME)/tools/bin/xrun

export LIBPYTHON_LOC = $(shell cocotb-config --libpython)
COCOTB        := $(shell cocotb-config --lib-name-path vpi xcelium)

TOPLEVEL      := {toplevel}
VPI_MODULES   := {modules}
VPI_PATH      :=
PARAMETERS    ?= {parameters}
PLUSARGS      ?= {plusargs}
XMSIM_OPTIONS ?= {xmsim_options}
XRUN_OPTIONS  ?= {xrun_options}
EXTRA_OPTIONS ?= $(XRUN_OPTIONS) $(if $(XMSIM_OPTIONS),-xmsimargs '$(XMSIM_OPTIONS)',) $(addprefix -defparam ,$(PARAMETERS)) $(addprefix +,$(PLUSARGS))

XRUN_CALL = $(XRUN) -q -f edalize_main.f -64 $(addprefix -loadvpi ,$(addsuffix :vlog_startup_routines_bootstrap,$(COCOTB))) $(addprefix -sv_lib ,$(VPI_PATH)) $(EXTRA_OPTIONS) -top $(TOPLEVEL)

all: $(VPI_MODULES)

run: $(VPI_MODULES)
	$(XRUN_CALL) -access rwc

run-gui: $(VPI_MODULES)
	$(XRUN_CALL) -gui -access rwc

clean: {clean_targets}
"""

VPI_MAKE_C_SECTION = """
{name}_OBJS := {objs}
{name}_LIBS := {libs}
{name}_INCS := $(INCS) {incs}

$({name}_OBJS): %.so : %.c
	$(CC) $(CFLAGS) $({name}_INCS) -o $@ $<

{name}: $({name}_OBJS)
	$(LD) $(LDFLAGS) -o $@ $? $({name}_LIBS)

clean_{name}:
	$(RM) $({name}_OBJS) {name}
"""

VPI_MAKE_CPP_SECTION = """
{name}_OBJS := {objs}
{name}_LIBS := {libs}
{name}_INCS := $(INCS) {incs}

$({name}_OBJS): %.so : %.cpp
	$(CPP) $(CPPFLAGS) $({name}_INCS) -o $@ $<

{name}: $({name}_OBJS)
	$(LD) $(LDCPPFLAGS) -o $@ $? $({name}_LIBS)

clean_{name}:
	$(RM) $({name}_OBJS) {name}
"""

VPI_CONNECT = """
VPI_PATH := $(foreach var,$(VPI_MODULES),$($(var)_OBJS))
"""

class Xcelium(Edatool):

    argtypes = ["plusarg", "vlogdefine", "vlogparam", "generic"]

    @classmethod
    def get_doc(cls, api_ver):
        if api_ver == 0:
            return {
                "description": "Xcelium simulator from Cadence Design Systems",
                "lists": [
                    {
                        "name": "xmvhdl_options",
                        "type": "String",
                        "desc": "Additional options for compilation with xmvhdl",
                    },
                    {
                        "name": "xmvlog_options",
                        "type": "String",
                        "desc": "Additional options for compilation with xmvlog",
                    },
                    {
                        "name": "xmsim_options",
                        "type": "String",
                        "desc": "Additional run options for xmsim",
                    },
                    {
                        "name": "xrun_options",
                        "type": "String",
                        "desc": "Additional run options for xrun",
                    },
                ],
            }

    def _write_build_rtl_f_file(self, tcl_main):
        tcl_build_rtl = open(os.path.join(self.work_root, "edalize_build_rtl.f"), "w")

        (src_files, incdirs) = self._get_fileset_files()

        vlog_include_dirs = ["+incdir+" + d.replace("\\", "/") for d in incdirs]

        src_files_dict = {
            'verilogSource': {},
            'systemVerilogSource': {},
            'vhdlSource': {},
            'vhdlSource-93': {},
            'vhdlSource-2008': {}
        }

        args_tools = {
            'verilogSource': [],
            'systemVerilogSource': ['-sv'],
            'vhdlSource': [],
            'vhdlSource-93': ['-v93'],
            'vhdlSource-2008': ['-v200x']
        }

        def put_in_dict(key: str, lib: str, fname: str):
            if not lib in src_files_dict[key]:
                src_files_dict[key][lib] = set()
                src_files_dict[key][lib].add(fname.replace("\\", "/"))
            else:
                src_files_dict[key][lib].add(fname.replace("\\", "/"))

        for f in src_files:
            if not f.logical_name:
                f.logical_name = "worklib"
            if f.file_type.startswith("verilogSource"):
                put_in_dict("verilogSource", f.logical_name, f.name)
            elif f.file_type.startswith("systemVerilogSource"):
                put_in_dict("systemVerilogSource", f.logical_name, f.name)
            elif f.file_type.startswith("vhdlSource"):
                if f.file_type.endswith("-93"):
                    put_in_dict("vhdlSource-93", f.logical_name, f.name)
                if f.file_type.endswith("-2008"):
                    put_in_dict("vhdlSource-2008", f.logical_name, f.name)
                else:
                    put_in_dict("vhdlSource", f.logical_name, f.name)
            elif f.file_type.startswith("tclSource"):
                cmd = None
                tcl_main.write("-input {}\n".format(f.name))
            elif f.file_type == "user":
                cmd = None
            else:
                _s = "{} has unknown file type '{}'"
                logger.warning(_s.format(f.name, f.file_type))
                cmd = None

        for key, value in src_files_dict.items():
            if key.startswith("verilogSource") or key.startswith("systemVerilogSource"):
                args_common = args_tools[key]

                args_common += self.tool_options.get("xmvlog_options", [])

                # Sort dictionary items, to ensure stable output, which makes testing easier
                for k, v in self.vlogdefine.items():
                    args_common += ["+define+{}={}".format(k, self._param_value_str(v))]

                args_common += vlog_include_dirs

            if key.startswith("vhdlSource"):
                args_common = args_tools[key]

                args_common += self.tool_options.get("xmvhdl_options", [])

            for lib, args in value.items():
                line = "-makelib {} {} -endlib".format(lib, " ".join(args_common+list(args)))
                tcl_build_rtl.write(line + "\n")

    def _write_makefile(self):
        vpi_make = open(os.path.join(self.work_root, "Makefile"), "w")
        _parameters = []
        for key, value in self.vlogparam.items():
            _parameters += ["{}={}".format(key, self._param_value_str(value))]
        for key, value in self.generic.items():
            _parameters += [
                "{}={}".format(key, self._param_value_str(value, bool_is_str=True))
            ]
        _plusargs = []
        for key, value in self.plusarg.items():
            _plusargs += ["{}={}".format(key, self._param_value_str(value))]

        _xmsim_options = self.tool_options.get("xmsim_options", [])
        _xrun_options = self.tool_options.get("xrun_options", [])

        _modules = [m["name"] for m in self.vpi_modules]
        _clean_targets = " ".join(["clean_" + m for m in _modules])
        _s = MAKE_HEADER.format(
            toplevel=self.toplevel,
            parameters=" ".join(_parameters),
            plusargs=" ".join(_plusargs),
            xmsim_options=" ".join(_xmsim_options),
            xrun_options=" ".join(_xrun_options),
            modules=" ".join(_modules),
            clean_targets=_clean_targets,
        )
        vpi_make.write(_s)

        for vpi_module in self.vpi_modules:
            _name = vpi_module["name"]
            _objs_cpp = None
            _objs_c   = None
            for s in vpi_module["src_files"]:
                if 'cpp' in os.path.splitext(s)[1]:
                    _objs_cpp = [os.path.splitext(s)[0] + ".so"]
                else:
                    _objs_c = [os.path.splitext(s)[0] + ".so"]
            _libs = ["-l" + l for l in vpi_module["libs"]]
            _incs = ["-I" + d for d in vpi_module["include_dirs"]]
            if not _objs_cpp == None:
                _s = VPI_MAKE_CPP_SECTION.format(
                    name=_name,
                    objs=" ".join(_objs_cpp),
                    libs=" ".join(_libs),
                    incs=" ".join(_incs),
                )
            if not _objs_c == None:
                _s = VPI_MAKE_C_SECTION.format(
                    name=_name,
                    objs=" ".join(_objs_c),
                    libs=" ".join(_libs),
                    incs=" ".join(_incs),
                )
            vpi_make.write(_s)

        vpi_make.write(VPI_CONNECT)

        vpi_make.close()

    def configure_main(self):
        tcl_main = open(os.path.join(self.work_root, "edalize_main.f"), "w")
        tcl_main.write("-f edalize_build_rtl.f\n")

        self._write_build_rtl_f_file(tcl_main)
        self._write_makefile()
        tcl_main.close()

    def run_main(self):
        args = ["run"]

        # Set plusargs
        if self.plusarg:
            plusargs = []
            for key, value in self.plusarg.items():
                plusargs += ["{}={}".format(key, self._param_value_str(value))]
            args.append("PLUSARGS=" + " ".join(plusargs))

        self._run_tool("make", args)
